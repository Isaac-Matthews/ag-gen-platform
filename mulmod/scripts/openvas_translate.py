#!/usr/bin/env python

# This script generates p files by parsing and filtering XML files generated by OpenVAS

# The following filters are implemented:
# Filter by IP Address (output single host)
# Filter by max/min CVSS score
# Filter by CVSS 'Threat Level'
# Filter by live/open host/ports in a CSV file (eg output by gnxparse.py)
# Author Isaac Matthews
# Inspired by goxparse by Glen

import sys, argparse
import mysql.connector

try:
    import xml.etree.cElementTree as ET
except ImportError:
    import xml.etree.ElementTree as ET
PROG = 0
RANGE = 1
IMPACT = 2
SEVERITY = 3
ACCESS = 4

def handle_opts():
    parser = argparse.ArgumentParser(
        formatter_class=argparse.RawDescriptionHelpFormatter,
        description='OpenVAS to p',
        usage='%(prog)s filename.xml [OPTIONS]',
        epilog="""\
usage examples:
	%(prog)s ./scan.xml -ips
	%(prog)s ./scan.xml -host <HOSTIP>
	%(prog)s ./scan.xml -cvssmin 5 -cvssmax 8
	%(prog)s ./scan.xml -threatlevel HIGH """
    )

    parser.add_argument('file', action='store',
                        help='File containing OpenVAS XML report')
    parser.add_argument('-i', '-ips', action='store_true', dest='ips',
                        help='Output unfiltered list of scanned ipv4 addresses')
    parser.add_argument('-host', action='store', dest='hostip', nargs='?', default='not_set',
                        help='Host to generate a report for')
    parser.add_argument('-cvssmin', action='store', dest='cvssmin', nargs='?', default='not_set',
                        help='Minimum CVSS level to report'),
    parser.add_argument('-cvssmax', action='store', dest='cvssmax', nargs='?', default='not_set',
                        help='Maximum CVSS level to report'),
    parser.add_argument('-threatlevel', action='store', dest='threat', nargs='?', default='not_set',
                        help='Threat Level to match, LOG/LOW/MEDIUM/HIGH/CRITICAL'),
    parser.add_argument('-matchfile', action='store', dest='matchfile', nargs='?', default='not_set',
                        help='.csv file from which to match open ports, in format HOSTIP,port1,port2,port3'),
    parser.add_argument('-v', '--version', action='version',
                        version='%(prog)s 1.0 (http://bitbucket.org/memoryresident/goxparse )'
                        )

    args = parser.parse_args()

    return args


def nocase_equal(x, y):
    try:
        return x.upper() == y.upper()
    except AttributeError:
        return x == y


def parse_ips(openvas_xml_blob):
    host_ip_list = [];
    for report in openvas_xml_blob.findall('./report'):
        for hostentry in report.findall('host'):
            for ipaddress in hostentry.findall('ip'):
                host_ip_list.append(ipaddress.text)
    return host_ip_list


def chop_port(portstring):
    # cut the portsection into service/port/protocol
    # converts from a string like "ssh (22/tcp)" into list
    # there is a difference in format between newer and older versions
    # of openvas, so the various sighted cases are covered here

    # Store port info in a dict with keys of service, protocol, port
    portinfo = {}

    # cases where port looks like "general/icmp"
    if portstring.startswith("general/"):
        portstringlist = portstring.split("/")
        portinfo['service'] = portstringlist[0]
        portinfo['protocol'] = portstringlist[1]
        portinfo['port'] = "N/A"

    # cases where port looks like "ntp(123/udp)"
    elif "(" in portstring:
        # replace: ")" with "", the middle "(" with a /, then split the whole thing on /
        portstringlist = portstring.replace(")", "").replace(" (", "/").split("/")
        portinfo['service'] = portstringlist[0]
        portinfo['protocol'] = portstringlist[2]
        portinfo['port'] = portstringlist[1]

    # otherwise: port looks like "123/udp"
    else:
        portstringlist = portstring.split("/")
        portinfo['service'] = ""  # empty for now so will leave it blank
        portinfo['protocol'] = portstringlist[1]
        portinfo['port'] = portstringlist[0]

    return portinfo


def read_csv_file(filename):
    try:
        csvfile = open(filename)
        csvlines = csvfile.readlines()
        csvfile.close()
    except:
        sys.exit("There was a problem opening the .csv file.")

    csv_hostport_list = {}

    # 1) Read line in csv file (format host,port0,port1,port2,etc)
    # 2) Split line by commas
    # 3) Pop the host entry from the list
    # 4) All remaining entries in line should be ports so append them to currentports list
    # 5) Return a dictionary of hosts => portlists

    for hostline in csvlines:
        line = hostline.split(",")
        currenthost = line.pop(0)

        currentports = []

        for port in line:
            currentports.append(port.replace("\n", ""))  # strip newlines from port string
        csv_hostport_list[currenthost] = currentports

    return csv_hostport_list


def print_result(host_result, csv_hostport_list):
    # Print a single result line to stdout in CSV format
    # Also print the header line if this is the first pass.

    # The csv (output) delimiter
    delimiter = ','
    # These blanks get replaced later.
    csvheader = ""
    csvportmatch = ""

    # check if the csv hostport is populated, if so add a column header and start checking for port matches
    if csv_hostport_list:
        csvheader = ('CSVPort Match' + delimiter)

        # crosscheck csv with xml results for port matches and set column value appropriately
        for ip_address in csv_hostport_list:
            # act on the ip for this host
            if ip_address == str(host_result['ip']):
                if str(host_result['port']) in csv_hostport_list[ip_address]:
                    csvportmatch = ('yes' + delimiter)
                    break  # exit loop
            else:
                csvportmatch = ('no' + delimiter)

    print (
        str(host_result['threat']) + delimiter +
        str(host_result['ip']) + delimiter +
        str(host_result['cvss']) + delimiter +
        str(host_result['service']) + delimiter +
        str(host_result['protocol']) + delimiter +
        str(host_result['port']) + delimiter +
        str(csvportmatch) +
        str(host_result['name']) + delimiter +
        str(host_result['cve'])
    )


def iterate_host_results(openvas_xml_blob, filters, csv_hostport_list):
    # for each result in the report
    results = []
    cveset = set()
    results.append(cveset)
    hostset = set()
    results.append(hostset)
    drops = 0
    for result in openvas_xml_blob.iter(tag='result'):
        try:
            host_result = {}

            # chop port info ahead of time so we only do it once
            portinfo = chop_port(result.find('port').text)

            # set all the info we want into host_result from the current result xml chunk
            ip = str(result.find('host').text)
            host_result['ip'] = ip
            results[1].add(ip)
            host_result['threat'] = str(result.find('threat').text)
            host_result['cvss'] = str(result.find('nvt/cvss_base').text)
            host_result['port'] = portinfo['port']
            host_result['protocol'] = portinfo['protocol']
            host_result['service'] = portinfo['service']
            cves = str(result.find('nvt/cve').text).replace(" ", "")  # have tried many variations here
            host_result['name'] = str(result.find('nvt/name').text)
            # if (type(host_result.find('cve')) != 'None'):
            # try:
            # host_result['cvss'] = float(host_result['cvss'])
            #	except:
            #		sys.exit(host_result['cvss'] + 'needs to be a number between 0.0 and 99.0')
            # host_result['cvss'] = float(host_result['cvss'])
            # Convert CVSS field to a float to allow some smarter range filtering later
            if (cves != 'NOCVE'):
                if (host_result['cvss'] != 'None'):
                    try:
                        host_result['cvss'] = float(host_result['cvss'])
                    except:
                        sys.exit(host_result['cvss'] + 'needs to be a number between 0.0 and 99.0')
                    host_result['cvss'] = float(host_result['cvss'])

                # Filter successively. Host line must run the gauntlet to be printed.

                if (nocase_equal(filters['threat'], host_result['threat'])) or (filters['threat'] == 'ALL'):
                    if (filters['ip'] == host_result['ip']) or (filters['ip'] == 'ALL'):

                        # if either filter is set
                        if (filters['cvssmin'] != 'not_set') or (filters['cvssmax'] != 'not_set'):

                            # check both for either/both not set and if so set them to a default
                            if (filters['cvssmin'] == 'not_set'):
                                filters['cvssmin'] = float('0.0')

                            if (filters['cvssmax'] == 'not_set'):
                                filters['cvssmax'] = float('99.9')

                            # Check if the value is not 'None'
                            if (host_result['cvss'] != 'None'):
                                # convert it to a float.
                                try:
                                    host_result['cvss'] = float(host_result['cvss'])
                                except:
                                    # might want something less nuclear than a sys.exit, like log it somewhere or ignore
                                    sys.exit(
                                        "For some reason the CVSS value listed against the host was neither a number or 'none'")

                                # if the host result is an actual number
                                # check the user hasn't given us a bad filter value for cvssmin/cvssmax
                                try:
                                    cvssmin = float(filters['cvssmin'])
                                    cvssmax = float(filters['cvssmax'])
                                except:
                                    sys.exit("Please enter min/max CVSS scores between 0 - 10")

                                cvss = float(host_result['cvss'])

                                if (cvssmin <= cvss <= cvssmax):
                                    for cve in cves.split(','):
                                        results[0].add(cve)
                                        host_result['cve']=cve
                                        #print_result(host_result, csv_hostport_list)
                                        results.append(host_result)
                                else:
                                    drops+=1
                        else:
                            for cve in cves.split(','):
                                results[0].add(cve)
                                host_result['cve']=cve
                                #print_result(host_result, csv_hostport_list)
                                results.append(host_result)
            else:
                drops+=1
        except:
            drops+=1
    print('Results dropped: '+str(drops) + ', ' +str(int((drops/(drops+len(results)))*100))+'%')
    return results

def connect():
    cnx = mysql.connector.connect(user='root', password='root', host='localhost', database='nvd')
    return cnx

def create_cve_dict(cves):
    cve_dict = dict()
    con = connect()
    cur = con.cursor()
    query= 'SELECT * FROM nvd WHERE id IN (\'{}\')'.format('\', \''.join(cves))
    #print(query)
    cur.execute(query)
    drop=0
    for row in cur:
        #prog dealt with separately
        if row[0]!='' and row[2]!='' and row[3]!='' and row[4]!='' and row[5]!='':
            cve_dict[row[0]]=[row[PROG+1],row[RANGE+1],row[IMPACT+1],row[SEVERITY+1],row[ACCESS+1]]
        else:
            drop+=1
        #print(row[0])
        #print(row[5])
    cur.close()
    con.close()
    print('dropped ' + str(drop) + ' from dictionary')
    return cve_dict

def to_file(file, cve_dict, results, hosts):
    with open((file.split('.')[0]+'.p'),'w+') as out:
        for cve in cve_dict.keys():
            #NOT SURE IF ASSUMED PRIVESCALATION IS OK
            out.write('vulProperty(\'{}\',{},privEscalation).\n\n'.format(cve,cve_dict[cve][RANGE].replace('\'','')))#,cve_dict[cve][IMPACT]))
        for result in results:
            if cve_dict.has_key(result['cve']):
                if (cve_dict[result['cve']][PROG]!=''): #use recorded name if no program found
                    if "." not in cve_dict[result['cve']][PROG]: #format it like mulval does
                        out.write('vulExists(\'{}\',\'{}\',\'{}\').\n\n'.format(result['ip'],result['cve'],cve_dict[result['cve']][PROG].replace('/','_')))
                    else:
                        out.write('vulExists(\'{}\',\'{}\',\'{}\').\n\n'.format(result['ip'],result['cve'],cve_dict[result['cve']][PROG].replace('/','_')))
                else:
                    out.write('vulExists(\'{}\',\'{}\',\'{}\').\n\n'.format(result['ip'],result['cve'],result['name'].lower().replace(" ","_").replace(".","_")))
            else:
                results.remove(result)
                print('removed'+result['cve'])
        for cve in cve_dict.keys():
            out.write('cvss(\'{}\',{}).\n\n'.format(cve,cve_dict[cve][ACCESS]))#,cve_dict[cve][IMPACT]))
        #DOES ORDER MATTER HERE??
        for result in results:
            if cve_dict.has_key(result['cve']):
                if (cve_dict[result['cve']][PROG]!=''):
                    if "." not in cve_dict[result['cve']][PROG]:
                        out.write('networkServiceInfo(\'{}\',\'{}\',{},\'{}\',someUser).\n\n'.format(result['ip'],cve_dict[result['cve']][PROG].replace('/','_'),result['protocol'],result['port']))
                    else:
                        out.write('networkServiceInfo(\'{}\',\'{}\',{},\'{}\',someUser).\n\n'.format(result['ip'],cve_dict[result['cve']][PROG].replace('/','_'),result['protocol'],result['port']))
                else:
                    out.write('networkServiceInfo(\'{}\',\'{}\',{},\'{}\',someUser).\n\n'.format(result['ip'],result['name'].lower().replace(" ","_"),result['protocol'],result['port']))
        for host in hosts:
            out.write('inCompetent(\'{}_victim\').\n'.format(host))
            out.write('hasAccount(\'{}_victim\', \'{}\', user).\n'.format(host,host))
            out.write('attackerLocated(internet).\n')
            out.write('attackGoal(execCode(\'{}\', _)).\n'.format(host))
        out.write('hacl(_,_,_,_).\n')
    out.closed

def main():
    args = handle_opts()
    try:
        openvas_xml_blob = ET.ElementTree(file=args.file)
    except:
        sys.exit("Please specify a valid OpenVAS XML file")

    filters = {'ip': "ALL", 'cvssmin': 'not_set', 'cvssmax': 'not_set', 'threat': "ALL"}

    if args.ips == True:
        print("IPv4 Addresses for scanned hosts:")
        host_ip_list = parse_ips(openvas_xml_blob)
        for ip_address in host_ip_list:
            print (ip_address);
        sys.exit()

    if args.hostip != "not_set":
        filters['ip'] = str(args.hostip)
    if args.cvssmin != "not_set":
        filters['cvssmin'] = args.cvssmin
    if args.cvssmax != "not_set":
        filters['cvssmax'] = args.cvssmax
    if args.threat != "not_set":
        filters['threat'] = args.threat
    if args.matchfile != "not_set":
        csv_hostport_list = read_csv_file(args.matchfile)
    else:
        csv_hostport_list = ""

    results = iterate_host_results(openvas_xml_blob, filters, csv_hostport_list)
    cves = results[0]
    del results[0]
    hosts = results[0]
    del results[0]
    cve_dict=create_cve_dict(cves)
    to_file(args.file, cve_dict, results, hosts)


if __name__ == "__main__":
    main()
